---
title: "Variables latentes"
subtitle: "Discrimination des saumons suivant leur provenance"
date: "2024-03"
categories: [Classifaction, ACP, PLS-DA]
image: "saumon-sauvage.jpg"
image_credit: "GETTY IMAGES/ISTOCKPHOTO / WILD & FREE"
---

# Apprentissage superviseÃÅ par une approche PLS

Discrimination des saumons suivant leur provenance et leur mode de production sur la base de donn√©es de caract√©risation chimique.

::: {style="text-align: center;"}
<iframe src="/pdf/projet_saumon.pdf" width="80%" height="500px">

</iframe>
:::

Vous avez la possibilit√© de t√©l√©charger le document ici :) [üì• T√©l√©charger le fichier PDF](/pdf/projet_saumon.pdf)

**Pr√©sentation du code**

Je vous pr√©sente ci-dessous, le code utilis√© pour mener √† bien ce projet, avec les √©tapes et explications correspondantes.

**Librairies**

```{r}
suppressPackageStartupMessages({
library(caret)
library(corrplot)
library(ggplot2)
library(FactoMineR)
library(factoextra)
library(mixOmics)
library(tidyr)
library(here)
})  
```

```{r}
saumon <- read.csv(here("data", "ICPMS_raw_data.csv"))

```

# Pr√©paration du jeu de donn√©es

Les 20 √©l√©ments restants ont √©t√© s√©lectionn√©s √† partir des donn√©es brutes de ICP-MS; Li, B, Al, V, Cr, Mn, Fe, Co, Ni, Cu, Zn, As, Se, Rb, Sr, Nb, Mo, Cd, Cs, Ta'

```{r}
str(saumon)
saumon <- saumon[c(1, 2, 4, 7, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28, 30, 31, 33)]
names(saumon) <- c("pays", "Li", "B", "Al", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "As", "Se", "Rb", "Sr", "Nb", "Mo", "Cd", "Cs", "Ta")

```

## Convertir la colonne pays en factor

```{r}
saumon$pays <- as.factor(saumon$pays)
summary(saumon)

```

## Configurer preProcess pour la normalisation min-max

```{r}
preproc <- preProcess(saumon,  method = "range")
saumon_norm <- predict(preproc, saumon)
```

## V√©rification de valeurs manquantes

`{sum(is.null(saumon))} str(saumon_norm)`

# Analyse descriptif

## Matrice de corr√©lation

```{r}

cor(saumon_norm[, -1], use = "complete.obs")

corrplot::corrplot(cor(saumon_norm[, -1]), method = "color", type = "upper", order="FPC", 
                   tl.cex = 0.6,
                   number.cex = 0.5,
                   addCoef.col = "black")
```

Distribution des valeurs observ√©s pour les diff√©rents variables

## Transformation des donn√©es en format long

```{r}

saumon_norm_long <- pivot_longer(saumon_norm, cols = -1, names_to = "variable", values_to = "value")
```

Histogrammes avec courbes de densit√© pour chaque variable

```{r}
ggplot(saumon_norm_long, aes(x = value)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "blue", color = "white") +
  geom_density(color = "red", linewidth = 1) +
  facet_wrap(~variable, scales = "free") +
  theme_minimal() +
  labs(y = "Densit√©", title = "Distribution des Variables avec Courbe de Densit√©")
```

Tableau de contingence des pays

```{r}
table(saumon_norm$pays)
```

## ACP FactoMineR

```{r}
pca_res <- PCA(saumon_norm[, -1], scale.unit = FALSE)
fviz_screeplot(pca_res)
fviz_pca_var(pca_res)
fviz_pca_var(pca_res, axes = c(2,3))
round(pca_res$var$cos2,2)
```

## ACP mixOmics

```{r}

pca.saumon = pca(saumon_norm[, -1], scale = FALSE, ncomp = 10, center = TRUE)
plotIndiv(pca.saumon, group = saumon_norm$pays, ind.names = FALSE,  legend = TRUE, 
          title = 'Saumons par Pays - ACP',
          size.title = rel(1))
```

## S√©paration du jeu de donn√©es en jeu d‚Äôentra√Ænement et jeu test

```{r}
intrain <- createDataPartition(saumon_norm$pays, p=0.8, list=FALSE)
#save(intrain,file="intrain.Rdata") # enregistrer intrain pour la reprod 
load(file = here("data", "intrain.Rdata"))# t√©lecharger le fichier

X.app <- saumon_norm[intrain, -1]
Y.app <- saumon_norm[intrain, 1]
X.test <- saumon_norm[-intrain, -1]
Y.test <- saumon_norm[-intrain, 1]
```

# Analyse Discriminante par les Moindres Carr√©s Partiels (PLS-DA)

```{r}
plsda.saumon <- mixOmics::plsda(X.app, Y.app, ncomp=10, scale = FALSE) #scale FALSE par defaut true
plotVar(plsda.saumon, comp = 1:2) # permet de voir les variables sur un graphique

plotIndiv(plsda.saumon, comp = 1:2, centroid = TRUE, ellipse = TRUE, legend = TRUE,
          title = "Projection d'√©chantillons PLSDA ")
plsda.saumon
```

# Choix de composantes

```{r}
set.seed(2024) # pour la reproductibit√© 
perf.saumon <- perf(plsda.saumon, validation = "Mfold", folds = 10,
                  progressBar = FALSE, auc = TRUE, nrepeat = 10)
```

Montre le nombre de composantes pour predire, avec plusieur options (max.dist, centroids) et la mahalanobis

```{r}
plot(perf.saumon, col = color.mixo(5:7), sd = TRUE, legend.position = "horizontal")

perf.saumon$choice.ncomp

perf.saumon$error.rate # montre le nombre d'erreur pour chaque regle
```

```{r}
nb_compo = 4 # nombre de composontes d√©finit
vip.saumon <- vip(plsda.saumon)[, nb_compo] 
barplot(vip.saumon, xlab = colnames(X.app), las=2, main = "Variable Importance in the Projection")
```

```{r}
barplot(vip.saumon, 
        las = 2,   # Orientations verticales des noms de variables
        main = "Variable Importance in the Projection",
        col = ifelse(vip.saumon > 1, "red", "grey"), # Variables importantes en rouge
        ylim = c(0, max(vip.saumon) * 1.1)) 
# Ajout d'une ligne de r√©f√©rence
abline(h=1, col="blue") 

auc.saumon = auroc(plsda.saumon, roc.comp = nb_compo)
```

# Taux d'erreur sur la base test

```{r}
plsda.fin.saumon <- plsda(X.app, Y.app, ncomp = nb_compo, scale = FALSE)
plsda.test <- predict(plsda.fin.saumon, dist="mahalanobis.dist", newdata= X.test)
plsda.test.fin <- plsda.test$class$mahalanobis.dist[,nb_compo]
```

# Matrice de confusion

```{r}
mat.confusion <- table(Y.test, plsda.test.fin)
mat.confusion
sum(diag(mat.confusion))/sum(mat.confusion) # calcul de l'exactitude du mod√©le 

1-sum(diag(mat.confusion))/sum(mat.confusion)
```

# M√©trique recall et precision

```{r}
precision <- diag(mat.confusion) / colSums(mat.confusion)  #  pour la pr√©cision
recall <- diag(mat.confusion) / rowSums(mat.confusion)  #  pour le rappel
print(precision)
print(recall)
```

# Calcul du score F1 pour chaque classe

```{r}
f1_score <- 2 * (precision * recall) / (precision + recall)
print(f1_score)
```

Pour connaitre les √©l√©ments importants pour chaque composant

```{r}
chargements <- loadings(plsda.fin.saumon)
chargements

par(mfrow=c(2,2)) # Configure l'affichage en grille 2x2

for(i in 1:4) {
  barplot(chargements$X[, paste("comp", i, sep="")], 
          main = paste("Composant", i), 
          las = 2, cex.names = 0.5, 
          col = rainbow(4)[i])
}

```
